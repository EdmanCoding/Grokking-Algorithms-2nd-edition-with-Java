import java.util.*;
// the fastest path for the exercise generated by AI. Check the image in the same folder
public class GeneratedExercise {
    public static void main(String[] args) {
        // Set up the graph
        Map<String, Map<String, Integer>> graph = new HashMap<>();

        // Add edges from START
        Map<String, Integer> startEdges = new HashMap<>();
        startEdges.put("A", 6);
        startEdges.put("B", 2);
        startEdges.put("C", 5);
        graph.put("START", startEdges);

        // Add edges from A
        Map<String, Integer> aEdges = new HashMap<>();
        aEdges.put("D", 3);
        aEdges.put("E", 8);
        aEdges.put("F", 7);
        graph.put("A", aEdges);

        // Add edges from B
        Map<String, Integer> bEdges = new HashMap<>();
        bEdges.put("E", 3);
        bEdges.put("F", 1);
        bEdges.put("G", 4);
        graph.put("B", bEdges);

        // Add edges from C
        Map<String, Integer> cEdges = new HashMap<>();
        cEdges.put("G", 6);
        cEdges.put("H", 9);
        graph.put("C", cEdges);

        // Add edges from D
        Map<String, Integer> dEdges = new HashMap<>();
        dEdges.put("I", 2);
        dEdges.put("J", 5);
        graph.put("D", dEdges);

        // Add edges from E
        Map<String, Integer> eEdges = new HashMap<>();
        eEdges.put("I", 1);
        eEdges.put("J", 4);
        eEdges.put("K", 3);
        graph.put("E", eEdges);

        // Add edges from F
        Map<String, Integer> fEdges = new HashMap<>();
        fEdges.put("J", 2);
        fEdges.put("K", 7);
        fEdges.put("L", 4);
        graph.put("F", fEdges);

        // Add edges from G
        Map<String, Integer> gEdges = new HashMap<>();
        gEdges.put("L", 5);
        gEdges.put("M", 8);
        graph.put("G", gEdges);

        // Add edges from H
        Map<String, Integer> hEdges = new HashMap<>();
        hEdges.put("M", 3);
        hEdges.put("L", 6);
        graph.put("H", hEdges);

        // Add edges from I
        Map<String, Integer> iEdges = new HashMap<>();
        iEdges.put("N", 4);
        iEdges.put("O", 7);
        graph.put("I", iEdges);

        // Add edges from J
        Map<String, Integer> jEdges = new HashMap<>();
        jEdges.put("N", 2);
        jEdges.put("O", 5);
        jEdges.put("P", 3);
        graph.put("J", jEdges);

        // Add edges from K
        Map<String, Integer> kEdges = new HashMap<>();
        kEdges.put("O", 1);
        kEdges.put("P", 6);
        graph.put("K", kEdges);

        // Add edges from L
        Map<String, Integer> lEdges = new HashMap<>();
        lEdges.put("P", 4);
        lEdges.put("S", 9);
        graph.put("L", lEdges);

        // Add edges from M
        Map<String, Integer> mEdges = new HashMap<>();
        mEdges.put("Q", 5);
        mEdges.put("T", 7);
        graph.put("M", mEdges);

        // Add edges from N
        Map<String, Integer> nEdges = new HashMap<>();
        nEdges.put("R", 3);
        graph.put("N", nEdges);

        // Add edges from O
        Map<String, Integer> oEdges = new HashMap<>();
        oEdges.put("R", 2);
        oEdges.put("S", 4);
        graph.put("O", oEdges);

        // Add edges from P
        Map<String, Integer> pEdges = new HashMap<>();
        pEdges.put("S", 1);
        pEdges.put("T", 8);
        graph.put("P", pEdges);

        // Add edges from Q
        Map<String, Integer> qEdges = new HashMap<>();
        qEdges.put("T", 3);
        graph.put("Q", qEdges);

        // Add edges from R
        Map<String, Integer> rEdges = new HashMap<>();
        rEdges.put("FIN", 2);
        graph.put("R", rEdges);

        // Add edges from S
        Map<String, Integer> sEdges = new HashMap<>();
        sEdges.put("FIN", 1);
        graph.put("S", sEdges);

        // Add edges from T
        Map<String, Integer> tEdges = new HashMap<>();
        tEdges.put("FIN", 5);
        graph.put("T", tEdges);

        // Add edges from FIN (no outgoing edges)
        Map<String, Integer> finEdges = new HashMap<>();
        graph.put("FIN", finEdges);

        // Initialize costs table
        Map<String, Integer> costs = new HashMap<>();
        costs.put("A", 6);
        costs.put("B", 2);
        costs.put("C", 5);
        costs.put("D", Integer.MAX_VALUE); // Infinity
        costs.put("E", Integer.MAX_VALUE);
        costs.put("F", Integer.MAX_VALUE);
        costs.put("G", Integer.MAX_VALUE);
        costs.put("H", Integer.MAX_VALUE);
        costs.put("I", Integer.MAX_VALUE);
        costs.put("J", Integer.MAX_VALUE);
        costs.put("K", Integer.MAX_VALUE);
        costs.put("L", Integer.MAX_VALUE);
        costs.put("M", Integer.MAX_VALUE);
        costs.put("N", Integer.MAX_VALUE);
        costs.put("O", Integer.MAX_VALUE);
        costs.put("P", Integer.MAX_VALUE);
        costs.put("Q", Integer.MAX_VALUE);
        costs.put("R", Integer.MAX_VALUE);
        costs.put("S", Integer.MAX_VALUE);
        costs.put("T", Integer.MAX_VALUE);
        costs.put("FIN", Integer.MAX_VALUE); // Infinity

        // Initialize parents table
        Map<String, String> parents = new HashMap<>();
        parents.put("A", "START");
        parents.put("B", "START");
        parents.put("C", "START");
        parents.put("D", null);
        parents.put("E", null);
        parents.put("F", null);
        parents.put("G", null);
        parents.put("H", null);
        parents.put("I", null);
        parents.put("J", null);
        parents.put("K", null);
        parents.put("L", null);
        parents.put("M", null);
        parents.put("N", null);
        parents.put("O", null);
        parents.put("P", null);
        parents.put("Q", null);
        parents.put("R", null);
        parents.put("S", null);
        parents.put("T", null);
        parents.put("FIN", null);

        // Track processed nodes
        Set<String> processed = new HashSet<>();

        // Run Dijkstra's algorithm
        dijkstra(graph, costs, parents, processed);

        // Print the shortest path to FIN
        System.out.println("Shortest path to FIN:");
        printPath(parents, "FIN");

        // Print the cost to FIN
        System.out.println("Total cost to FIN: " + costs.get("FIN"));
    }

    private static void dijkstra(Map<String, Map<String, Integer>> graph,
                                 Map<String, Integer> costs,
                                 Map<String, String> parents,
                                 Set<String> processed) {
        String node = findLowestCostNode(costs, processed);
        while (node != null) {
            int cost = costs.get(node);
            Map<String, Integer> neighbors = graph.get(node);

            // Update costs for all neighbors
            for (String n : neighbors.keySet()) {
                int newCost = cost + neighbors.get(n);
                // If it's cheaper to get to this neighbor through this node
                if (costs.get(n) > newCost) {
                    // Update the cost for the neighbor
                    costs.put(n, newCost);
                    // This node becomes the new parent for this neighbor
                    parents.put(n, node);
                }
            }
            // Mark this node as processed
            processed.add(node);
            // Find the next node to process
            node = findLowestCostNode(costs, processed);
        }
    }
    private static String findLowestCostNode(Map<String, Integer> costs, Set<String> processed) {
        int lowestCost = Integer.MAX_VALUE;
        String lowestCostNode = null;
        // Go through all nodes
        for (String node : costs.keySet()) {
            int cost = costs.get(node);
            // If it's the lowest cost so far and hasn't been processed yet
            if (cost < lowestCost && !processed.contains(node)) {
                lowestCost = cost;
                lowestCostNode = node;
            }
        }
        return lowestCostNode;
    }
    private static void printPath(Map<String, String> parents, String endNode) {
        List<String> path = new ArrayList<>();
        String currentNode = endNode;
        while (currentNode != null) {
            path.add(0, currentNode);
            currentNode = parents.get(currentNode);
        }
        for (int i = 0; i < path.size(); i++) {
            System.out.print(path.get(i));
            if (i < path.size() - 1) {
                System.out.print(" -> ");
            }
        }
        System.out.println();
    }
}
